{
  "version": 3,
  "sources": ["../src/core-errors.ts", "../src/core-helpers.ts", "../src/default-import.ts", "../src/freeze.ts"],
  "sourcesContent": ["import { BaseError } from 'make-error';\nimport { ErrorConstant } from '@remirror/core-constants';\n\nimport { includes, isString, values } from './core-helpers';\n\n/**\n * Errors have their own URL which will be logged to the console for simpler\n * debugging.\n */\nconst ERROR_INFORMATION_URL = 'https://remirror.io/docs/errors';\n\nconst errorMessageMap: Partial<Record<ErrorConstant, string>> = {\n  [ErrorConstant.UNKNOWN]: \"An error occurred but we're not quite sure why. \uD83E\uDDD0\",\n  [ErrorConstant.INVALID_COMMAND_ARGUMENTS]:\n    'The arguments passed to the command method were invalid.',\n  [ErrorConstant.CUSTOM]: 'This is a custom error, possibly thrown by an external library.',\n  [ErrorConstant.CORE_HELPERS]:\n    'An error occurred in a function called from the `@remirror/core-helpers` library.',\n  [ErrorConstant.MUTATION]: 'Mutation of immutable value detected.',\n  [ErrorConstant.INTERNAL]:\n    'This is an error which should not occur and is internal to the remirror codebase.',\n  [ErrorConstant.MISSING_REQUIRED_EXTENSION]: 'Your editor is missing a required extension.',\n  [ErrorConstant.MANAGER_PHASE_ERROR]:\n    'This occurs when accessing a method or property before it is available.',\n  [ErrorConstant.INVALID_GET_EXTENSION]:\n    'The user requested an invalid extension from the getExtensions method. Please check the `createExtensions` return method is returning an extension with the defined constructor.',\n  [ErrorConstant.INVALID_MANAGER_ARGUMENTS]:\n    'Invalid value(s) passed into `Manager` constructor. Only `Presets` and `Extensions` are supported.',\n  [ErrorConstant.SCHEMA]:\n    \"There is a problem with the schema or you are trying to access a node / mark that doesn't exists.\",\n  [ErrorConstant.HELPERS_CALLED_IN_OUTER_SCOPE]:\n    'The `helpers` method which is passed into the ``create*` method should only be called within returned method since it relies on an active view (not present in the outer scope).',\n  [ErrorConstant.INVALID_MANAGER_EXTENSION]: 'You requested an invalid extension from the manager.',\n  [ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'Command method names must be unique within the editor.',\n  [ErrorConstant.DUPLICATE_HELPER_NAMES]: 'Helper method names must be unique within the editor.',\n  [ErrorConstant.NON_CHAINABLE_COMMAND]: 'Attempted to chain a non chainable command.',\n  [ErrorConstant.INVALID_EXTENSION]: 'The provided extension is invalid.',\n  [ErrorConstant.INVALID_CONTENT]: 'The content provided to the editor is not supported.',\n  [ErrorConstant.INVALID_NAME]: 'An invalid name was used for the extension.',\n  [ErrorConstant.EXTENSION]:\n    'An error occurred within an extension. More details should be made available.',\n  [ErrorConstant.EXTENSION_SPEC]:\n    'The spec was defined without calling the `defaults`, `parse` or `dom` methods.',\n  [ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES]:\n    'Extra attributes must either be a string or an object.',\n  [ErrorConstant.INVALID_SET_EXTENSION_OPTIONS]:\n    'A call to `extension.setOptions` was made with invalid keys.',\n  [ErrorConstant.REACT_PROVIDER_CONTEXT]:\n    '`useRemirrorContext` was called outside of the `remirror` context. It can only be used within an active remirror context created by the `<Remirror />`.',\n  [ErrorConstant.REACT_GET_ROOT_PROPS]:\n    '`getRootProps` has been attached to the DOM more than once. It should only be attached to the dom once per editor.',\n  [ErrorConstant.REACT_EDITOR_VIEW]: 'A problem occurred adding the editor view to the dom.',\n  [ErrorConstant.REACT_CONTROLLED]: 'There is a problem with your controlled editor setup.',\n  [ErrorConstant.REACT_NODE_VIEW]: 'Something went wrong with your custom ReactNodeView Component.',\n  [ErrorConstant.REACT_GET_CONTEXT]:\n    'You attempted to call `getContext` provided by the `useRemirror` prop during the first render of the editor. This is not possible and should only be after the editor first mounts.',\n  [ErrorConstant.REACT_COMPONENTS]: 'An error occurred within a remirror component.',\n  [ErrorConstant.REACT_HOOKS]: 'An error occurred within a remirror hook.',\n\n  [ErrorConstant.I18N_CONTEXT]: 'You called `useI18n()` outside of an `I18nProvider` context.',\n};\n\n/**\n * Checks whether the passed code is an `ErrorConstant`.\n */\nfunction isErrorConstant(code: unknown): code is ErrorConstant {\n  return isString(code) && includes(values(ErrorConstant), code);\n}\n\n/**\n * Create an error message from the provided error code.\n */\nfunction createErrorMessage(code: ErrorConstant, extraMessage?: string) {\n  const message = errorMessageMap[code];\n  const prefix = message ? `${message}\\n\\n` : '';\n  const customMessage = extraMessage ? `${extraMessage}\\n\\n` : '';\n\n  return `${prefix}${customMessage}For more information visit ${ERROR_INFORMATION_URL}#${code.toLowerCase()}`;\n}\n\n/**\n * This marks the error as a remirror specific error, with enhanced stack\n * tracing capabilities.\n *\n * @remarks\n *\n * Use this when creating your own extensions and notifying the user that\n * something has gone wrong.\n */\nexport class RemirrorError extends BaseError {\n  /**\n   * A shorthand way of creating an error message.\n   */\n  static create(options: RemirrorErrorOptions = {}): RemirrorError {\n    return new RemirrorError(options);\n  }\n\n  /**\n   * The error code used to create this error message.\n   */\n  errorCode: ErrorConstant;\n\n  /**\n   * The link to read more about the error online.\n   */\n  url: string;\n\n  /**\n   * The constructor is intentionally kept private to prevent being extended from.\n   */\n  private constructor({ code, message, disableLogging = false }: RemirrorErrorOptions = {}) {\n    const errorCode: ErrorConstant = isErrorConstant(code) ? code : ErrorConstant.CUSTOM;\n    super(createErrorMessage(errorCode, message));\n\n    this.errorCode = errorCode;\n    this.url = `${ERROR_INFORMATION_URL}#${errorCode.toLowerCase()}`;\n\n    if (!disableLogging) {\n      // Log the error.\n      // eslint-disable-next-line no-console\n      console.error(this.message);\n    }\n  }\n}\n\n/**\n * Throw an error if the condition fails. Strip out error messages for\n * production. Adapted from `tiny-invariant`.\n */\nexport function invariant(condition: unknown, options: RemirrorErrorOptions): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  throw RemirrorError.create(options);\n}\n\n/**\n * The invariant options which only show up during development.\n */\nexport interface RemirrorErrorOptions {\n  /**\n   * The code for the built in error.\n   */\n  code?: ErrorConstant;\n\n  /**\n   * The message to add to the error.\n   */\n  message?: string;\n\n  /**\n   * When true logging to the console is disabled.\n   *\n   * @defaultValue false\n   */\n  disableLogging?: boolean;\n}\n", "import { cx as classNames } from '@linaria/core';\nimport type { ClassName } from '@linaria/core/types/cx';\nimport deepmerge from 'deepmerge';\nimport fastDeepEqual from 'fast-deep-equal';\nimport { BaseError } from 'make-error';\nimport omit from 'object.omit';\nimport pick from 'object.pick';\nimport { __INTERNAL_REMIRROR_IDENTIFIER_KEY__ } from '@remirror/core-constants';\nimport type {\n  AnyConstructor,\n  AnyFunction,\n  ConditionalExcept,\n  JsonPrimitive,\n  Nullable,\n  Primitive,\n  Shape,\n  UnknownShape,\n} from '@remirror/types';\n\ntype TupleRange<Size extends number> = Size extends Size\n  ? number extends Size\n    ? number[]\n    : _NumberRangeTuple<[], Size>\n  : never;\ntype _NumberRangeTuple<\n  Tuple extends readonly unknown[],\n  Length extends number,\n> = Tuple['length'] extends Length ? Tuple : _NumberRangeTuple<[...Tuple, Tuple['length']], Length>;\n\n/**\n * Type cast an argument. If no type is provided it will default to any.\n *\n * @param arg - the arg to typecast\n */\nexport function Cast<Type = any>(value: unknown): Type {\n  return value as Type;\n}\n\n/**\n * Get the key from a given value. Throw an error if the referenced property is\n * `undefined`.\n */\nexport function assertGet<Value extends object, Key extends keyof Value>(\n  value: Value,\n  key: Key,\n  message?: string,\n): Value[Key] {\n  const prop = value[key];\n  assert(!isUndefined(prop), message);\n\n  return prop;\n}\n\n/**\n * Assert the value is `truthy`. Good for defensive programming, especially\n * after enabling `noUncheckedIndexedAccess` in the tsconfig `compilerOptions`.\n */\nexport function assert(testValue: unknown, message?: string): asserts testValue {\n  if (!testValue) {\n    throw new AssertionError(message);\n  }\n}\n\nclass AssertionError extends BaseError {\n  name = 'AssertionError';\n}\n\n/**\n * A typesafe implementation of `Object.entries()`\n *\n * Taken from\n * https://github.com/biggyspender/ts-entries/blob/master/src/ts-entries.ts\n */\nexport function entries<\n  Type extends object,\n  Key extends Extract<keyof Type, string>,\n  Value extends Type[Key],\n  Entry extends [Key, Value],\n>(value: Type): Entry[] {\n  return Object.entries(value) as Entry[];\n}\n\n/**\n * A typesafe implementation of `Object.keys()`\n */\nexport function keys<Type extends object, Key extends Extract<keyof Type, string>>(\n  value: Type,\n): Key[] {\n  return Object.keys(value) as Key[];\n}\n\n/**\n * A typesafe implementation of `Object.values()`\n */\nexport function values<\n  Type extends object,\n  Key extends Extract<keyof Type, string>,\n  Value extends Type[Key],\n>(value: Type): Value[] {\n  return Object.values(value) as Value[];\n}\n\n/**\n * A more lenient typed version of `Array.prototype.includes` which allow less\n * specific types to be checked.\n */\nexport function includes<Type>(\n  array: Type[] | readonly Type[],\n  item: unknown,\n  fromIndex?: number,\n): item is Type {\n  return array.includes(item as Type, fromIndex);\n}\n\n/**\n * Creates an object with the null prototype.\n *\n * @param value - the object to create\n */\nexport function object<Type extends object>(value?: Type): Type {\n  return Object.assign(Object.create(null), value);\n}\n\n/**\n * A type name matcher for object types.\n *\n * @private\n */\nenum TypeName {\n  Object = 'Object',\n  RegExp = 'RegExp',\n  Date = 'Date',\n  Promise = 'Promise',\n  Error = 'Error',\n  Map = 'Map',\n  Set = 'Set',\n}\n\n/**\n * Alias of toString for non-dom environments.\n *\n * This is a safe way of calling `toString` on objects created with\n * `Object.create(null)`.\n */\nexport function toString(value: unknown): string {\n  return Object.prototype.toString.call(value);\n}\n\n/**\n * Retrieve the object type of a value via it's string reference. This is safer\n * than relying on instanceof checks which fail on cross-frame values.\n *\n * @param value - the object to inspect\n */\nfunction getObjectType(value: unknown): TypeName | undefined {\n  const objectName = toString(value).slice(8, -1);\n\n  return objectName as TypeName;\n}\n\n/**\n * A helper for building type predicates\n *\n * @param type -  the name of the type to check for\n * @returns a predicate function for checking the value type\n */\nfunction isOfType<Type>(type: string, predicate?: (value: Type) => boolean) {\n  return (value: unknown): value is Type => {\n    if (typeof value !== type) {\n      return false;\n    }\n\n    return predicate ? predicate(value as Type) : true;\n  };\n}\n\n/**\n * Get the object type of passed in value. This avoids the reliance on\n * `instanceof` checks which are subject to cross frame issues as outlined in\n * this link https://bit.ly/1Qds27W\n *\n * @param type - the name of the object type to check for\n *\n * @private\n */\nfunction isObjectOfType<Type>(type: TypeName) {\n  return (value: unknown): value is Type => getObjectType(value) === type;\n}\n\n/**\n * Check if an instance is the direct instance of the provided class.\n */\nexport function isDirectInstanceOf<Type>(\n  instance: unknown,\n  Constructor: AnyConstructor<Type>,\n): instance is Type {\n  return Object.getPrototypeOf(instance) === Constructor.prototype;\n}\n\n/**\n * Predicate check that value is undefined\n *\n * @param value - the value to check\n *\n */\nexport const isUndefined = isOfType<undefined>('undefined');\n\n/**\n * Predicate check that value is a string\n *\n * @param value - the value to check\n *\n */\nexport const isString = isOfType<string>('string');\n\n/**\n * Predicate check that value is a number.\n *\n * Also by default doesn't include NaN as a valid number.\n *\n * @param value - the value to check\n *\n */\nexport const isNumber = isOfType<number>('number', (value) => {\n  return !Number.isNaN(value);\n});\n\n/**\n * Predicate check that value is a function\n *\n * @param value - the value to check\n *\n */\nexport const isFunction = isOfType<AnyFunction>('function');\n\n/**\n * Predicate check that value is null\n *\n * @param value - the value to check\n *\n */\nexport function isNull(value: unknown): value is null {\n  return value === null;\n}\n\n/**\n * Predicate check that value is a class\n *\n * @deprecated Due to the current build process stripping out classes\n *\n * @param value - the value to check\n *\n */\nexport function isClass(value: unknown): value is AnyConstructor {\n  return isFunction(value) && value.toString().startsWith('class ');\n}\n\n/**\n * Predicate check that value is boolean\n *\n * @param value - the value to check\n *\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return value === true || value === false;\n}\n\n/**\n * Predicate check that value is a symbol\n *\n * @param value - the value to check\n *\n */\nexport const isSymbol = isOfType<symbol>('symbol');\n\n/**\n * Helper function for Number.isInteger check allowing non numbers to be tested\n *\n * @param value - the value to check\n *\n */\nexport function isInteger(value: unknown): value is number {\n  return Number.isInteger(value as number);\n}\n\n/**\n * Helper function for Number.isSafeInteger allowing for unknown values to be\n * tested\n *\n * @param value - the value to check\n *\n */\nexport function isSafeInteger(value: unknown): value is number {\n  return Number.isSafeInteger(value as number);\n}\n\n/**\n * Predicate check for whether passed in value is a plain object\n *\n * @param value - the value to check\n *\n */\nexport function isPlainObject<Type = unknown>(value: unknown): value is UnknownShape<Type> {\n  if (getObjectType(value) !== TypeName.Object) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n\n  return prototype === null || prototype === Object.getPrototypeOf({});\n}\n\n/**\n * Predicate check for whether passed in value is a primitive value\n */\nexport function isPrimitive(value: unknown): value is Primitive {\n  return value == null || /^[bns]/.test(typeof value);\n}\n\n/**\n * Predicate check for whether passed in value is a JSON primitive value\n */\nexport function isJSONPrimitive(value: unknown): value is JsonPrimitive {\n  return value === null || ['boolean', 'number', 'string'].includes(typeof value);\n}\n\n/**\n * Utility predicate check that value is either null or undefined\n *\n * @param value - the value to check\n *\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return isNull(value) || isUndefined(value);\n}\n/**\n * Predicate check that value is an object.\n *\n * @param value - the value to check\n *\n */\nexport function isObject<Type extends Shape>(value: unknown): value is Type {\n  return !isNullOrUndefined(value) && (isFunction(value) || isOfType('object')(value));\n}\n\n/**\n * A shorthand method for creating instance of checks.\n */\nexport function isInstanceOf<Constructor extends AnyConstructor>(Constructor: Constructor) {\n  return (value: unknown): value is InstanceType<Constructor> =>\n    isObject(value) && value instanceof Constructor;\n}\n\n/**\n * Predicate check that value is a native promise\n *\n * @param value - the value to check\n *\n */\nexport function isNativePromise(value: unknown): value is Promise<unknown> {\n  return isObjectOfType<Promise<unknown>>(TypeName.Promise)(value);\n}\n\n/**\n * Check to see if a value has the built in promise API.\n *\n * @param value - the value to check\n *\n */\nconst hasPromiseAPI = (value: unknown): value is Promise<unknown> => {\n  return !!(\n    !isNull(value) &&\n    (isObject(value) as unknown) &&\n    isFunction((value as Promise<unknown>).then) &&\n    isFunction((value as Promise<unknown>).catch)\n  );\n};\n\n/**\n * Predicate check that value has the promise api implemented\n *\n * @param value - the value to check\n *\n */\nexport function isPromise(value: unknown): value is Promise<unknown> {\n  return isNativePromise(value) || hasPromiseAPI(value);\n}\n\n/**\n * Predicate check that value is a RegExp\n *\n * @param value - the value to check\n *\n */\nexport const isRegExp = isObjectOfType<RegExp>(TypeName.RegExp);\n\n/**\n * Predicate check that value is a date\n *\n * @param value - the value to check\n *\n */\nexport const isDate = isObjectOfType<Date>(TypeName.Date);\n\n/**\n * Predicate check that value is an error\n *\n * @param value - the value to check\n *\n */\nexport const isError = isObjectOfType<Error>(TypeName.Error);\n\n/**\n * Predicate check that value is a `Map`\n *\n * @param value - the value to check\n *\n */\nexport function isMap(value: unknown): value is Map<unknown, unknown> {\n  return isObjectOfType<Map<unknown, unknown>>(TypeName.Map)(value);\n}\n\n/**\n * Predicate check that value is a `Set`\n *\n * @param value - the value to check\n *\n */\nexport function isSet(value: unknown): value is Set<unknown> {\n  return isObjectOfType<Set<unknown>>(TypeName.Set)(value);\n}\n\n/**\n * Predicate check that value is an empty object\n *\n * @param value - the value to check\n *\n */\nexport function isEmptyObject(value: unknown): boolean {\n  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;\n}\n\n/**\n * Alias the isArray method.\n */\nexport const isArray = Array.isArray;\n\n/**\n * Predicate check that value is an empty array\n *\n * @param value - the value to check\n *\n */\nexport function isEmptyArray(value: unknown): value is never[] {\n  return isArray(value) && value.length === 0;\n}\n\n/**\n * Predicate check that value is a non-empty.\n *\n * @param value - the value to check\n *\n */\nexport function isNonEmptyArray<Item>(value: Item[]): value is [Item, ...Item[]] {\n  return isArray(value) && value.length > 0;\n}\n\n/**\n * Capitalizes a string value.\n *\n * @param str - the string to capitalize.\n */\nexport function capitalize(string: string): string {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n/**\n * Trim and conditionally capitalize string values.\n *\n * @param str - the string to format.\n *\n */\nexport function format(value: string): string {\n  value = value.trim();\n  return /^(?:webOS|i(?:OS|P))/.test(value) ? value : capitalize(value);\n}\n\n/**\n * Calls a function if defined and provides compile time type checking for the\n * passed in parameters.\n *\n * @param fn - the function to call if it exists\n * @param args - the rest of the parameters with types\n */\nexport function callIfDefined<Method extends AnyFunction>(\n  fn: Nullable<Method>,\n  ...args: Parameters<Method>\n): void {\n  if (isFunction(fn)) {\n    fn(...args);\n  }\n}\n\n/**\n * Finds all the regex matches for a string\n *\n * @param text - the text to check against\n * @param regexp - the regex (which should include a 'g' flag)\n *\n */\nexport function findMatches(\n  text: string,\n  regexp: RegExp,\n  runWhile: (match: RegExpExecArray | null) => boolean = (match) => !!match,\n): RegExpExecArray[] {\n  regexp.lastIndex = 0;\n\n  const results: RegExpExecArray[] = [];\n  const flags = regexp.flags;\n  let match: RegExpExecArray | null;\n\n  if (!flags.includes('g')) {\n    regexp = new RegExp(regexp.source, `g${flags}`);\n  }\n\n  do {\n    match = regexp.exec(text);\n\n    if (match) {\n      results.push(match);\n    }\n  } while (runWhile(match));\n\n  regexp.lastIndex = 0;\n  return results;\n}\n\n/**\n * A utility function to clean up the Operating System name.\n *\n * @param os - the OS name to clean up.\n * @param pattern - a `RegExp` pattern matching the OS name.\n * @param label - a label for the OS.\n * @returns a cleaned up Operating System name\n */\nexport function cleanupOS(os: string, pattern?: string, label?: string): string {\n  if (pattern && label) {\n    os = os.replace(new RegExp(pattern, 'i'), label);\n  }\n\n  return format(\n    os\n      .replace(/ ce$/i, ' CE')\n      .replace(/\\bhpw/i, 'web')\n      .replace(/\\bMacintosh\\b/, 'Mac OS')\n      .replace(/_powerpc\\b/i, ' OS')\n      .replace(/\\b(os x) [^\\d ]+/i, '$1')\n      .replace(/\\bMac (OS X)\\b/, '$1')\n      .replace(/\\/(\\d)/, ' $1')\n      .replace(/_/g, '.')\n      .replace(/(?: bepc|[ .]*fc[\\d .]+)$/i, '')\n      .replace(/\\bx86\\.64\\b/gi, 'x86_64')\n      .replace(/\\b(Windows Phone) OS\\b/, '$1')\n      .replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, '$1')\n      .split(' on ')[0] ?? '',\n  );\n}\n\n/**\n * A utility function to check whether the current browser is running on the\n * android platform.\n */\nexport function isAndroidOS(): boolean {\n  const ua = navigator.userAgent;\n  const match = new RegExp('\\\\b' + 'Android' + '(?:/[\\\\d.]+|[ \\\\w.]*)', 'i').exec(ua);\n\n  if (!match) {\n    return false;\n  }\n\n  return cleanupOS(match[0] ?? '', 'Android', 'Android').includes('Android');\n}\n\n/**\n * Generate a random float between min and max. If only one parameter is\n * provided minimum is set to 0.\n *\n * @param min - the minimum value\n * @param max - the maximum value\n *\n */\nexport function randomFloat(min: number, max?: number): number {\n  if (!max) {\n    max = min;\n    min = 0;\n  }\n\n  return Math.random() * (max - min + 1) + min;\n}\n\n/**\n * Generate a random integer between min and max. If only one parameter is\n * provided minimum is set to 0.\n *\n * @param min - the minimum value\n * @param max - the maximum value\n *\n */\nexport function randomInt(min: number, max?: number): number {\n  return Math.floor(randomFloat(min, max));\n}\n\n/**\n * Converts a string, including strings in camelCase or snake_case, into Start\n * Case (a variant of Title case where all words start with a capital letter),\n * it keeps original single quote and hyphen in the word.\n *\n *   'management_companies' to 'Management Companies' 'managementCompanies' to\n *   'Management Companies' `hell's kitchen` to `Hell's Kitchen` `co-op` to\n *   `Co-op`\n *\n * @param str - the string to examine\n */\nexport function startCase(string: string): string {\n  return string\n    .replace(/_/g, ' ')\n    .replace(/([a-z])([A-Z])/g, (_, $1: string, $2: string) => `${$1} ${$2}`)\n    .replace(/(\\s|^)(\\w)/g, (_, $1: string, $2: string) => `${$1}${$2.toUpperCase()}`);\n}\n\n/**\n * Returns a number that is unique during the runtime of this code.\n */\nfunction n() {\n  const time = Date.now();\n  const last = n.last || time;\n  return (n.last = time > last ? time : last + 1);\n}\n\nn.last = 0;\n\n/**\n * Generate a unique id\n *\n * @param prefix - a prefix for the generated id.\n * @returns a unique string of specified length\n *\n */\nexport function uniqueId(prefix = ''): string {\n  return `${prefix}${n().toString(36)}`;\n}\n\n/**\n * Takes a number of elements from the provided array starting from the\n * zero-index\n *\n * @param arr - the array to take from\n * @param num - the number of items to take\n *\n */\nexport function take<Type>(array: Type[], number: number): Type[] {\n  number = Math.max(Math.min(0, number), number);\n  return array.slice(0, number);\n}\n\n/**\n * Remove the undefined values from an object.\n */\nexport function omitUndefined<Type extends object>(\n  object: Type,\n): ConditionalExcept<Type, undefined> {\n  return omit(object, (value) => !isUndefined(value)) as any;\n}\n\n/**\n * Clones a plain object using object spread notation\n *\n * @param value - the value to check\n *\n */\nexport function clone<Type extends object>(value: Type): Type {\n  if (!isPlainObject(value)) {\n    throw new Error('An invalid value was passed into this clone utility. Expected a plain object');\n  }\n\n  return { ...value };\n}\n\n/**\n * Shallow clone an object while preserving it's getters and setters. This is a\n * an alternative to the spread clone.\n */\nexport function shallowClone<Type extends object>(value: Type): Type {\n  const clone = Object.create(Object.getPrototypeOf(value));\n  const descriptors = Object.getOwnPropertyDescriptors(value);\n  Object.defineProperties(clone, descriptors);\n\n  return clone;\n}\n\n/**\n * Alias for fast deep equal\n */\nexport const isEqual = fastDeepEqual;\n\n/**\n * Create a unique array in a non-mutating manner\n *\n * @param array - the array which will be reduced to its unique elements\n * @param fromStart - when set to true the duplicates will be removed from the\n * beginning of the array. This defaults to false.\n *\n * @returns a new array containing only unique elements (by reference)\n *\n */\nexport function uniqueArray<Type>(array: Type[], fromStart = false): Type[] {\n  const array_ = fromStart ? [...array].reverse() : array;\n  const set = new Set(array_);\n  return fromStart ? [...set].reverse() : [...set];\n}\n\n/**\n * Flattens an array.\n *\n * @param array\n *\n */\nexport function flattenArray<Type>(array: any[]): Type[] {\n  const flattened: any[] = [];\n\n  for (const item of array) {\n    const itemsToInsert = isArray(item) ? flattenArray(item) : [item];\n    flattened.push(...itemsToInsert);\n  }\n\n  return flattened;\n}\n\n/**\n * noop is a shorthand way of saying `No Operation` and is a function that does\n * nothing.\n *\n * And Sometimes doing nothing is the best policy.\n */\nexport function noop(): undefined {\n  return;\n}\n\n/**\n * A deep merge which only merges plain objects and Arrays. It clones the object\n * before the merge so will not mutate any of the passed in values.\n *\n * To completely remove a key you can use the `Merge` helper class which\n * replaces it's key with a completely new object\n */\nexport function deepMerge<Type = any>(...objects: Array<object | unknown[]>): Type {\n  return deepmerge.all<Type>(objects as any, { isMergeableObject: isPlainObject });\n}\n\ninterface ClampProps {\n  min: number;\n  max: number;\n  value: number;\n}\n\n/**\n * Clamps the value to the provided range.\n */\nexport function clamp({ min, max, value }: ClampProps): number {\n  if (value < min) {\n    return min;\n  }\n\n  return value > max ? max : value;\n}\n\n/**\n * Get the last element of the array.\n */\nexport function last<Type>(array: Type[]): Type {\n  return array[array.length - 1];\n}\n\n/**\n * Sorts an array while retaining the original order when the compare method\n * identifies the items as equal.\n *\n * `Array.prototype.sort()` is unstable and so values that are the same will\n * jump around in a non deterministic manner. Here I'm using the index as a\n * fallback. If two elements have the same priority the element with the lower\n * index is placed first hence retaining the original order.\n *\n * @param array - the array to sort\n * @param compareFn - compare the two value arguments `a` and `z` - return 0 for\n *                  equal - return number > 0 for a > z - return number < 0 for\n *                  z > a\n */\nexport function sort<Type>(array: Type[], compareFn: (a: Type, z: Type) => number): Type[] {\n  return [...array]\n    .map((value, index) => ({ value, index }))\n    .sort((a, z) => compareFn(a.value, z.value) || a.index - z.index)\n    .map(({ value }) => value);\n}\n\n/**\n * Get a property from an object or array by a string path or an array path.\n *\n * @param obj - object to retrieve property from\n * @param path - path to property\n */\nexport function get<Return>(root: Shape, path: string | string[], defaultValue?: unknown): Return {\n  try {\n    if (isString(path) && path in root) {\n      return (root as any)[path];\n    }\n\n    if (isArray(path)) {\n      path = `['${path.join(\"']['\")}']`;\n    }\n\n    let obj = root;\n    path.replace(\n      /\\[\\s*([\"'])(.*?)\\1\\s*]|^\\s*(\\w+)\\s*(?=\\.|\\[|$)|\\.\\s*(\\w*)\\s*(?=\\.|\\[|$)|\\[\\s*(-?\\d+)\\s*]/g,\n      (_, __, quotedProp, firstLevel, namedProp, index) => {\n        obj = obj[quotedProp || firstLevel || namedProp || index];\n        return '';\n      },\n    );\n\n    return (obj === undefined ? defaultValue : obj) as Return;\n  } catch {\n    return defaultValue as Return;\n  }\n}\n\nfunction setPropInternal<Type extends object = any>(\n  path: Array<string | number>,\n  obj: any,\n  value: any,\n  index: number,\n): Type {\n  if (path.length === index) {\n    return value;\n  }\n\n  // Create things as we go down if they don't exist\n  obj = obj || {};\n\n  const key = path[index];\n\n  assert(key);\n  return setClone(obj, key, setPropInternal(path, obj[key], value, ++index));\n}\n\nfunction setClone(obj: any, key: string | number, value: any) {\n  const newObj = clone(obj);\n  newObj[key] = value;\n  return newObj;\n}\n\n/**\n * Set the value of a given path for the provided object. Does not mutate the\n * original object.\n */\nexport function set(\n  path: number | string | Array<string | number>,\n  obj: Shape,\n  value: unknown,\n): Shape {\n  if (isNumber(path)) {\n    return setClone(obj, path, value);\n  }\n\n  if (isString(path)) {\n    path = path.split('.');\n  }\n\n  return setPropInternal(path, obj, value, 0);\n}\n\n/**\n * Unset the value of a given path within an object.\n */\nexport function unset(path: Array<string | number>, target: Shape): Shape {\n  const clonedObject = clone(target);\n  let value = clonedObject;\n\n  for (const [index, key] of path.entries()) {\n    const shouldDelete = index >= path.length - 1;\n    let item = value[key];\n\n    if (shouldDelete) {\n      if (isArray(value)) {\n        const indexKey = Number.parseInt(key.toString(), 10);\n\n        if (isNumber(indexKey)) {\n          value.splice(indexKey, 1);\n        }\n      } else {\n        Reflect.deleteProperty(value, key);\n      }\n\n      return clonedObject;\n    }\n\n    if (isPrimitive(item)) {\n      return clonedObject;\n    }\n\n    item = isArray(item) ? [...item] : { ...item };\n\n    value[key] = item;\n    value = item;\n  }\n\n  return clonedObject;\n}\n\nfunction makeFunctionForUniqueBy<Item extends Shape = Shape>(value: string | string[]) {\n  return (item: Item) => {\n    return get(item, value as string);\n  };\n}\n\n/**\n * Create a unique array of objects from a getter function or a property list.\n *\n * @param array - the array to extract unique values from\n * @param getValue - a getter function or a string with the path to the item\n * that is being used as a a test for uniqueness.\n * @param fromStart - when true will remove duplicates from the start rather\n * than from the end\n *\n * ```ts\n * import { uniqueBy } from '@remirror/core-helpers';\n *\n * const values = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], item => item.id);\n * log(values) // => [{id: 'a', value: 'Awesome'}]\n *\n * const byKey = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], 'id')\n * // Same as above\n * ```\n */\nexport function uniqueBy<Item = any>(\n  array: Item[],\n  getValue: ((item: Item) => unknown) | string | string[],\n  fromStart = false,\n): Item[] {\n  const unique: Item[] = [];\n  const found: Set<unknown> = new Set();\n\n  const getter = isFunction(getValue) ? getValue : makeFunctionForUniqueBy(getValue);\n  const list = fromStart ? [...array].reverse() : array;\n\n  for (const item of list) {\n    const value = getter(item);\n\n    if (!found.has(value)) {\n      found.add(value);\n      unique.push(item);\n    }\n  }\n\n  return fromStart ? unique.reverse() : unique;\n}\n\n/**\n * Create a range from start to end.\n *\n * If only start is provided it creates an array of the size provided. if start\n * and end are provided it creates an array who's first position is start and\n * final position is end. i.e. `length = (end - start) + 1`.\n *\n * If you'd like to create a typed tuple of up to `40` items then pass in a\n * `[number]` tuple as the first argument.\n */\nexport function range<Size extends number>(size: [Size]): TupleRange<Size>;\nexport function range(size: number): number[];\nexport function range(start: number, end: number): number[];\nexport function range(start: number | [number], end?: number): number[] {\n  const startValue = isArray(start) ? start[0] : start;\n\n  if (!isNumber(end)) {\n    return Array.from(\n      { length: Math.abs(startValue) },\n      (_, index) => (startValue < 0 ? -1 : 1) * index,\n    );\n  }\n\n  if (startValue <= end) {\n    return Array.from({ length: end + 1 - startValue }, (_, index) => index + startValue);\n  }\n\n  return Array.from({ length: startValue + 1 - end }, (_, index) => -1 * index + startValue);\n}\n\n/**\n * Check that a number is within the minimum and maximum bounds of a set of\n * numbers.\n *\n * @param value - the number to test\n */\nexport function within(value: number, ...rest: Array<number | undefined | null>): boolean {\n  const numbers: number[] = rest.filter<number>(isNumber);\n  return value >= Math.min(...numbers) && value <= Math.max(...numbers);\n}\n\n/**\n * Safe implementation of hasOwnProperty with typechecking.\n *\n * @remarks\n *\n * See {@link https://eslint.org/docs/rules/no-prototype-builtins}\n *\n * @param obj - the object to check\n * @param key - the property to check\n *\n * @typeParam Obj - the object type\n * @typeParam Property - the property which can be a string | number | symbol\n */\nexport function hasOwnProperty<Obj extends object, Property extends string | number | symbol>(\n  object_: Obj,\n  key: Property,\n): object_ is Property extends keyof Obj ? Obj : Obj & { Key: unknown } {\n  return Object.prototype.hasOwnProperty.call(object_, key);\n}\n\n/**\n * Helper for getting an array from a function or array.\n */\nexport function getLazyArray<Type>(value: Type[] | (() => Type[])): Type[] {\n  if (isFunction(value)) {\n    return value();\n  }\n\n  return value;\n}\n\nexport function cx(...classes: ClassName[]): string {\n  return uniqueArray(classNames(...classes).split(' ')).join(' ');\n}\n\n// The following are forward exports for other libraries. I've structured it\n// like this since these libraries are used multiple times within the codebase.\n\nexport {\n  camelCase,\n  capitalCase,\n  constantCase,\n  kebabCase,\n  pascalCase,\n  pathCase,\n  snakeCase,\n  spaceCase,\n} from 'case-anything';\nexport type {\n  debounce as DebouncedFunction,\n  throttle as ThrottledFunction,\n} from 'throttle-debounce';\nexport { debounce, throttle } from 'throttle-debounce';\nexport { omit, pick };\n", "// Copy from https://github.com/JacobLey/jacobley/blob/ed11c6e096c9995764fe3351b72a6c9e149cdf00/tools/default-import/src/default-import.ts\n// License: MIT\n\n/**\n * Fixes the default import for a CommonJS module.\n *\n * @internal\n *\n * @remark\n *\n * With ESM it is possible to export both a default value and multiple named exports.\n * With CJS it is possible to \"mock\" ESM functionality with a `__esModule=true` flag\n * but still only export a single \"default\" export, or multiple named exports.\n *\n * This helper method detects when a library tries to do a \"default\" export with other named values\n * and returns the \"intended\" default value.\n *\n * It also handles CJS exports that export an entire object via `module.exports = {}` rather than export syntax,\n * as well as extracting the `default` (if exists) from a dynamic import.\n *\n * Note there is not \"namedExport\" equivalent because it is assumed module loaders successfully parse that\n * out for both CJS and ESM.\n *\n * @param {*} mod - \"default\" export that might be wrapped in another layer\n * @returns {*} unwrapped module\n */\nexport function defaultImport<T>(mod: T): T {\n  if (typeof mod !== 'object' || mod === null) {\n    return mod;\n  }\n\n  // Webpack provides a Module tag to match NodeJS' Module module\n  const defaultVal =\n    Symbol.toStringTag in mod &&\n    (mod as unknown as { [Symbol.toStringTag]: string; default: T })[Symbol.toStringTag] ===\n      'Module'\n      ? (mod as unknown as { [Symbol.toStringTag]: 'Module'; default?: T }).default ?? mod\n      : mod;\n\n  if (\n    defaultVal &&\n    typeof mod === 'object' &&\n    '__esModule' in defaultVal &&\n    (defaultVal as any).__esModule &&\n    (defaultVal as any).default !== undefined\n  ) {\n    return (defaultVal as any).default;\n  }\n\n  return defaultVal;\n}\n", "/// <reference types=\"node\" />\n\nimport { ErrorConstant } from '@remirror/core-constants';\n\nimport { invariant } from './core-errors';\nimport { isArray, isObject } from './core-helpers';\n\n/**\n * A freeze method for objects that only runs in development. Helps prevent code\n * that shouldn't be mutated from being mutated during development.\n *\n * @remarks\n *\n * This function passes the value back unchanged when in a production\n * environment. It's purpose is to help prevent bad practice while developing\n * by avoiding mutation of values that shouldn't be mutated.\n */\nexport function freeze<Target extends object>(\n  target: Target,\n  options: FreezeOptions = {},\n): Readonly<Target> {\n  if (process.env.NODE_ENV === 'production') {\n    return target;\n  }\n\n  invariant(isObject(target) || isArray(target), {\n    message: '`freeze` only supports objects and arrays.',\n    code: ErrorConstant.CORE_HELPERS,\n  });\n\n  return new Proxy(target, {\n    get: (target, prop, receiver) => {\n      invariant(prop in target || !options.requireKeys, {\n        message: `The prop: '${prop.toString()}' you are trying to access does not yet exist on the target.`,\n      });\n\n      return Reflect.get(target, prop, receiver);\n    },\n    set: (_, prop) => {\n      invariant(false, {\n        message: `It seems you're trying to set the value of the property (${String(\n          prop,\n        )}) on a frozen object. For your protection this object does not allow direct mutation.`,\n        code: ErrorConstant.MUTATION,\n      });\n    },\n  });\n}\n\ninterface FreezeOptions {\n  /**\n   * Whether the key that is being accessed should exist on the target object.\n   *\n   * @defaultValue undefined\n   */\n  requireKeys?: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
