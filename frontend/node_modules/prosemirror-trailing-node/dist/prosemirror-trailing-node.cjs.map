{
  "version": 3,
  "sources": ["../src/index.ts", "../src/trailing-node-plugin.ts"],
  "sourcesContent": ["export type { TrailingNodePluginOptions } from './trailing-node-plugin';\nexport { trailingNode } from './trailing-node-plugin';\n", "import { NodeType } from 'prosemirror-model';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport { includes, uniqueArray } from '@remirror/core-helpers';\n\nexport interface TrailingNodePluginOptions {\n  /**\n   * The node to create at the end of the document.\n   *\n   * **Note**: the nodeName will always be added to the `ignoredNodes` lists to\n   * prevent an infinite loop.\n   *\n   * @defaultValue 'paragraph'\n   */\n  nodeName?: string;\n\n  /**\n   * The nodes for which this rule should not apply.\n   */\n  ignoredNodes?: string[];\n}\n\nconst trailingNodePluginKey = new PluginKey<boolean>('trailingNode');\n\n/**\n * This creates the plugin for trailing node.\n *\n * ```ts\n * import { schema } from 'prosemirror-schema-basic';\n * import { trailingNode } from 'prosemirror-trailing-node';\n *\n * // Include the plugin in the created editor state.\n * const state = EditorState.create({\n *   schema,\n *   plugins: [trailingNode({ ignoredNodes: [], nodeName: 'paragraph' })],\n * });\n * ```\n *\n * @param options - the options that can be provided to this plugin.\n */\nexport function trailingNode(options?: TrailingNodePluginOptions): Plugin<boolean> {\n  const { ignoredNodes = [], nodeName = 'paragraph' } = options ?? {};\n\n  // The names of the nodes for which this rule should not be applied.\n  const ignoredNodeNames: string[] = uniqueArray([...ignoredNodes, nodeName]);\n\n  // The node that will be inserted when the criteria match.\n  let type: NodeType;\n\n  // The list of nodes for this schema that should have content injected after\n  // them.\n  let types: NodeType[];\n\n  return new Plugin<boolean>({\n    key: trailingNodePluginKey,\n    appendTransaction(_, __, state) {\n      const { doc, tr } = state;\n      const shouldInsertNodeAtEnd = trailingNodePluginKey.getState(state);\n      const endPosition = doc.content.size;\n\n      if (!shouldInsertNodeAtEnd) {\n        return;\n      }\n\n      return tr.insert(endPosition, type.create());\n    },\n    state: {\n      init: (_, { doc, schema }) => {\n        const nodeType = schema.nodes[nodeName];\n\n        if (!nodeType) {\n          throw new Error(`Invalid node being used for trailing node extension: '${nodeName}'`);\n        }\n\n        // Save the type for continued use.\n        type = nodeType;\n        types = Object.values(schema.nodes)\n          .map((node) => node)\n          .filter((node) => !ignoredNodeNames.includes(node.name));\n\n        return includes(types, doc.lastChild?.type);\n      },\n      apply: (tr, value) => {\n        if (!tr.docChanged) {\n          return value;\n        }\n\n        return includes(types, tr.doc.lastChild?.type);\n      },\n    },\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,+BAAkC;AAClC,0BAAsC;AAmBtC,IAAM,wBAAwB,IAAI,mCAAmB,cAAc;AAkB5D,sBAAsB,SAAsD;AACjF,QAAM,EAAE,eAAe,CAAC,GAAG,WAAW,gBAAgB,4BAAW,CAAC;AAGlE,QAAM,mBAA6B,qCAAY,CAAC,GAAG,cAAc,QAAQ,CAAC;AAG1E,MAAI;AAIJ,MAAI;AAEJ,SAAO,IAAI,gCAAgB;AAAA,IACzB,KAAK;AAAA,IACL,kBAAkB,GAAG,IAAI,OAAO;AAC9B,YAAM,EAAE,KAAK,OAAO;AACpB,YAAM,wBAAwB,sBAAsB,SAAS,KAAK;AAClE,YAAM,cAAc,IAAI,QAAQ;AAEhC,UAAI,CAAC,uBAAuB;AAC1B;AAAA,MACF;AAEA,aAAO,GAAG,OAAO,aAAa,KAAK,OAAO,CAAC;AAAA,IAC7C;AAAA,IACA,OAAO;AAAA,MACL,MAAM,CAAC,GAAG,EAAE,KAAK,aAAa;AAlEpC;AAmEQ,cAAM,WAAW,OAAO,MAAM;AAE9B,YAAI,CAAC,UAAU;AACb,gBAAM,IAAI,MAAM,yDAAyD,WAAW;AAAA,QACtF;AAGA,eAAO;AACP,gBAAQ,OAAO,OAAO,OAAO,KAAK,EAC/B,IAAI,CAAC,SAAS,IAAI,EAClB,OAAO,CAAC,SAAS,CAAC,iBAAiB,SAAS,KAAK,IAAI,CAAC;AAEzD,eAAO,kCAAS,OAAO,UAAI,cAAJ,mBAAe,IAAI;AAAA,MAC5C;AAAA,MACA,OAAO,CAAC,IAAI,UAAU;AAjF5B;AAkFQ,YAAI,CAAC,GAAG,YAAY;AAClB,iBAAO;AAAA,QACT;AAEA,eAAO,kCAAS,OAAO,SAAG,IAAI,cAAP,mBAAkB,IAAI;AAAA,MAC/C;AAAA,IACF;AAAA,EACF,CAAC;AACH;",
  "names": []
}
